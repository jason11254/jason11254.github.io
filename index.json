[{"categories":["筆記"],"contents":"REST (Representational State Transfer) ful API，是一種設計風格。\n規則如下：\n  使用 http method 表示後端動作。\n範例：\n   Http Method 對應DB操作     GET SELECT   POST INSERT   PUT UPDATE   DELETE DELETE      使用URL路徑描述資源之間的階層關係。\n範例：\n   Http Method 說明     GET /students 取得所有的學生資料   GET /students/11034 取得id為11034的學生資料   DELETE /students/11034 刪除id為11034的學生資料      後端返回資料必須是json或xml格式。\n  RESTful 風格並非標準規範，作用僅是減少工程師之間的溝通成本。\n當碰上敏感資料時(身分證,信用卡號)，依然使用安全性較高的方法即可。\n","permalink":"https://jason11254.github.io/blog/restful/","tags":["RESTful"],"title":"RESTful設計風格"},{"categories":["筆記"],"contents":"IoC (Inversion of Control) - 控制反轉，將object的控制權交給Spring容器管理。\n由Spring容器管理的object則稱為bean。\nSpring IoC簡易流程   在目標class上加上@Component：\n@Component只能加在class上，使用後即可將該class變為Spring容器管理的bean。\n  @Component\rpublic class Apple {\rpublic void print(String message){\rSystem.out.println(\u0026#34;這顆蘋果，\u0026#34;+message);\r}\r} 在需要該物件的class上也加上@Component：  @Component\rpublic class Person {\r...\r}  最後使用@Autowired將bean注入物件，完成DI (Dependency Inject) - 依賴注入。\n@Autowired只能加在物件上，用於取得Spring容器中的bean。\n範例中取得了Spring容器中Apple的bean，注入物件apple。\n  @Component\rpublic class Person {\r@Autowired\rprivate Apple apple;\rpublic void myApple(){\rapple.print(\u0026#34;是我的。\u0026#34;);\r}\r}  創建main運行myApple()方法後即可看到console上的運行結果：這顆蘋果，是我的。\n而使用Spring容器建立的bean注入至物件中即是IoC的流程。\n  Spring IoC 優點：  使程式之間關聯性降低，在修改上可以不用到處尋找其他有關聯到的地方。 object的生命週期由Spring容器管理，無須工程師手動操作。  ","permalink":"https://jason11254.github.io/blog/springioc/","tags":["Java","Spring","IoC"],"title":"Spring學習筆記01-IoC簡介"},{"categories":["筆記"],"contents":"AOP (Aspect Oriented Programming) 切面導向程式設計，意思是將很多方法使用的共同邏輯寫在切面裡，由切面統一處理這段程式。\n這裡假設沒有使用切面，每次執行方法時都必須在方法程式開始時輸出【開始】與方法程式結束時【結束】，那麼程式碼會長這樣：\npublic class ExampleClass{\rpublic void fun01(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r...\r一些方法程式\r...\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 如範例所見，必須在進入方法時與方法結束時加入print語法來輸出文字。只有一個方法時還很輕鬆，但當有10個方法時，這段程式就必須重複寫10次。\n而由AOP統一處理時則不需要重複寫這段程式，僅需要設定好切面，由切面去執行輸出【開始】與【結束】的任務。\n切面基礎設定  在要成為切面的class上加上@Aspect與@Component，兩個標籤順序不重要，但必須兩者都存在。  @Aspect\r@Component\rpublic class MyAspect {\r...\r}  使用@Before與@After標籤，即可設定在方法前後需要執行的程式。\n切入點設定範例：@Before (\u0026ldquo;execution(* 路徑.目標Class.*(..))\u0026quot;)，\n上面的設定會讓目標Class中所有方法執行前都先執行Before內的程式，After設定寫法相同。\n  @Aspect\r@Component\rpublic class MyAspect {\r@Before(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void before(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r}\r@After(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void after(){\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 拿掉原本在目標Class內寫的print方法，範例為ExampleClass。  public class ExampleClass{\rpublic void fun01(){\r...\r一些方法程式\r...\r}\r} 建立main執行fun01()方法即可看到執行前後切面自動輸出【開始】與【結束】。 可以使用@Around來同時設定before與after，但是設定起來比較麻煩。得到的結果會跟上面@Before跟@After的結果一樣。  @Aspect\r@Component\rpublic class MyAspect {\r@Around(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic Object around(ProceedingJoinPoint pjp) throws Throwable{\rSystem.out.println(\u0026#34;開始\u0026#34;);\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之上就是before。\rObject obj = pjp.proceed();\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之下就是after。\rSystem.out.println(\u0026#34;結束\u0026#34;);\rreturn obj;\r}\r} Spring AOP的發展  權限認證 e.g. Spring Security 統一處理Exceptuon e.g. @ControllerAdvice Log  ","permalink":"https://jason11254.github.io/blog/springaop/","tags":["Java","Spring","AOP"],"title":"Spring學習筆記02-AOP簡介"},{"categories":["筆記"],"contents":"Spring 前後端請求與回應 簡單筆記。\nHttp 協議：規定前後端程式之間的資料傳輸格式。\n格式如下：\n   Http Request (請求) Http Response(回應)     http method (get,post,put\u0026hellip;等) http status code (200,404 \u0026hellip; 等)   url (網址) response header   request header response body   request body     HTTP 狀態碼 (http status code) http 狀態碼依照首位數字不同分為五大類。\n   狀態碼 常見範例     1xx：資訊 很少用   2xx：成功 200 (請求成功)，201(請求成功且資源被創建)，202(請求成功，但後端尚未處理完成)   3xx：重新導向 301 (永久重新導向，通常出現在網站搬家)，302(暫時重新導向)   4xx：前端請求錯誤 400 (前端參數請求錯誤)，401 (沒通過身分驗證)，403 (請求遭到拒絕)，404 (網站不存在)   5xx：後端處理錯誤 500 (後端發生錯誤，可能為bug導致)    URL 路徑對應 使用標籤@RequestMapping，範例如下：\n當前端發送請求至 url：/student 時，可以用以下方法對應。\n@RequestMapping(\u0026#34;/student\u0026#34;)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 配合Rest風格可以限制前端必須使用何種 http method 發送請求。\n範例限制必須以GET來發送請求：\n@RequestMapping(value = \u0026#34;/students\u0026#34;, method = RequestMethod.GET)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 若覺得上面這樣設定太麻煩也能直接使用@GetMapping，@PostMapping，@PutMapping，@DeleteMapping標籤代替@RequestMapping。\n修改上方範例：\n@GetMapping(\u0026#34;/student\u0026#34;)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 即可得到相同效果。\n取得 Request 參數方法   當參數放在url路徑內的問號後面時，url：/students?id=11040303\n使用 @RequestParam 取得參數，且參數名稱需與url中的名稱相同。也可以使用name=\u0026ldquo;參數名\u0026quot;來指定要的資料，但不建議。\n範例：\nurl：/product?id=41252\n@RequestMapping(\u0026#34;/product\u0026#34;)\rpublic String testRequestParam(@RequestParam Integer id){\rSystem.out.println(\u0026#34;商品編號為：\u0026#34;+id);\rreturn \u0026#34;success\u0026#34;;\r}   當參數放在request body 時，使用 @RequestBody 取得 requestbody 內的 json 內容。\n範例：\nurl：/testBody\nrequestbody：{\u0026ldquo;id\u0026rdquo;:123, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Amy\u0026rdquo; }\nclass Student{\rprivate Integer id;\rprivate String name;\r...\rgetter and setter\r...\r} @RequestMapping(\u0026#34;/testBody\u0026#34;)\rpublic String testRequestBody(@RequestBody Student student){\rSystem.out.println(\u0026#34;id: \u0026#34; + student.getId());\rSystem.out.println(\u0026#34;name: \u0026#34; + student.getName());\rreturn \u0026#34;success\u0026#34;;\r}   當參數放在request header 時，使用 @RequestHeader 取得 requestHeader 內的參數。\n範例：\nurl：/testHeader\nrequestheader：Content-Type:application/json\n@RequestMapping(\u0026#34;/testHeader\u0026#34;)\rpublic String testHeader(@RequestHeader(name=\u0026#34;Content-Type\u0026#34;) String info){\rSystem.out.println(\u0026#34;info: \u0026#34; + info);\rreturn \u0026#34;success\u0026#34;;\r} 由於Java內需使用駝峰式命名法，但Content-Type不屬於此類，因此使用name=\u0026ldquo;Content-Type\u0026rdquo; 來直接指定要這個header資料。\n  當參數直接放在url路徑上時，使用@PathVariable來取得路徑上的參數。\n範例：\nurl：/testUrl/4104321/Judy\n@RequestMapping(\u0026#34;/testUrl/{id}/{name}\u0026#34;)\rpublic String testPathVariable(@PathVariable Integer id,@PathVariable String name){\rSystem.out.println(\u0026#34;Path id: \u0026#34; + id + \u0026#34;, Path name: \u0026#34; + name);\rreturn \u0026#34;success\u0026#34;;\r}   ","permalink":"https://jason11254.github.io/blog/spring%E8%AB%8B%E6%B1%82%E8%88%87%E5%9B%9E%E6%87%89/","tags":["Java","Spring","HTTP"],"title":"Spring學習筆記03-前後端請求與回應"}]