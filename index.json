[{"categories":["筆記"],"contents":"MyBatis是一個優秀的持久層框架，它對jdbc的操作資料庫的過程進行封裝，使開發者只需要關注 SQL 本身，而不需要花費精力去處理例如註冊驅動、創建connection、創建statement、手動設置參數、結果集檢索等jdbc繁雜的過程代碼。\n相比Hibernate完全ORM的框架，MyBatis在查詢上因為是工程師手動寫SQL，所以靈活性較高。\nSpring Boot 中的 MyBatis設定   pom.xml 中加入導入包。\nmysql：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;\r\u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt;\r\u0026lt;/dependency\u0026gt; mybatis：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt; Spring boot的一些導入包(本體starter與test建立專案時已經建立)：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt; 其他：lombok\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;\r\u0026lt;/dependency\u0026gt;   配置文件 application.properties\n# mysql setting\rpring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\rspring.datasource.url=jdbc:mysql://localhost:3306/[DB名稱]?serverTimezone=Asia/Taipei\u0026amp;characterEncoding=utf-8\rspring.datasource.username=[帳號]\rspring.datasource.password=[密碼]\r# mybatis setting\rmybatis.type-aliases-package=com.example.mybatistest.model # 這一行設定物件class位置，這樣寫Mapping文件時，就不用打出完整路徑了。\rmybatis.mapper-locations=classpath:mybatis/mapper/*.xml # 這一行設定mapper.xml的位置，這樣mybatis才找的到sql在哪裡。   比照上面設定檔在 com/example/mybatistest 路徑建立資料夾 model，並創建對應 DB Table 的物件class。(請先去DB建立好Table再來撰寫)\n範例：Student.java\npackage com.example.mybatistest.model;\rimport lombok.AllArgsConstructor;\rimport lombok.Data;\rimport lombok.NoArgsConstructor;\r@Data\r@NoArgsConstructor\r@AllArgsConstructor\rpublic class Student {\rprivate Integer id;\rprivate String name;\r}   在 com/example/mybatistest 路徑建立資料夾 mapper，並創建介面Mapper。且須在上方加上註解@Mapper與@Repository(@Component)。\n然後便可以開始寫一些需要mybatis執行的方法。\n範例：StudentMapper.java\npackage com.example.mybatistest.mapper;\rimport com.example.mybatistest.model.Student;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.springframework.stereotype.Component;\rimport org.springframework.stereotype.Repository;\rimport java.util.List;\r@Mapper // 這個註解表示這是一個 mybatis mapper\r@Repository\r//@Component 這個與 @Repository 二選一\rpublic interface StudentMapper{\rList\u0026lt;Student\u0026gt; queryStudentList();\rStudent getById(Integer id);\r}   比照第2點的設定檔，在 resources 資料夾下建立資料夾mybatis，後在mybatis下再建立資料夾mapper。\n於mapper下建立Mapper.xml檔案(檔名通常會與介面名稱一樣)，並在裡面編寫SQL。\n範例：StudentMapper.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt;\r\u0026lt;!DOCTYPE mapper\rPUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34;\r\u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt;\r\u0026lt;!-- 這裡要填入mapper.java的位置 --\u0026gt;\r\u0026lt;mapper namespace=\u0026#34;com.example.mybatistest.mapper.StudentMapper\u0026#34;\u0026gt;\r\u0026lt;!-- 如果 application.properties 沒設定 mybatis.type-aliases-package 的話，\r這裡的 resultType 會變成 com.example.mybatistest.model.Student，\r而不是只寫Student。\r--\u0026gt;\r\u0026lt;select id=\u0026#34;queryStudentList\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; SELECT * FROM student\r\u0026lt;/select\u0026gt;\r\u0026lt;select id=\u0026#34;getById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt;\rSELECT * FROM student WHERE id=#{id}\r\u0026lt;/select\u0026gt;\r\u0026lt;/mapper\u0026gt;   然後開始測試，這裡找其中一個方法來測。\n建立Service：\npackage com.example.mybatistest.service;\rimport com.example.mybatistest.model.Student;\rpublic interface StudentService {\rpublic Student getById(Integer id);\r} package com.example.mybatistest.service;\rimport com.example.mybatistest.mapper.StudentMapper;\rimport com.example.mybatistest.model.Student;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Component;\r@Component\rpublic class StudentServiceImpl implements StudentService{\r@Autowired\rStudentMapper studentMapper;\r@Override\rpublic Student getById(Integer id) {\rStudent student = studentMapper.getById(id);\rreturn student;\r}\r} 建立Controller：\npackage com.example.mybatistest.controller;\rimport com.example.mybatistest.model.Student;\rimport com.example.mybatistest.service.StudentService;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RestController;\r@RestController\rpublic class StudentController {\r@Autowired\rprivate StudentService studentService;\r@RequestMapping(\u0026#34;/students/{id}\u0026#34;)\rpublic Student getById(@PathVariable Integer id){\rStudent student = studentService.getById(id);\rreturn student;\r}\r} 執行後於瀏覽器輸入：http://localhost:8080/students/2 即可得到回傳的結果。\n  ","permalink":"https://jason11254.github.io/blog/mybatis/","tags":["Java","Spring","MyBatis"],"title":"SpringBoot 整合 MyBatis 環境設定"},{"categories":["筆記"],"contents":"REST (Representational State Transfer) ful API，是一種設計風格。\n規則如下：\n  使用 http method 表示後端動作。\n範例：\n   Http Method 對應DB操作     GET SELECT   POST INSERT   PUT UPDATE   DELETE DELETE      使用URL路徑描述資源之間的階層關係。\n範例：\n   Http Method 說明     GET /students 取得所有的學生資料   GET /students/11034 取得id為11034的學生資料   DELETE /students/11034 刪除id為11034的學生資料      後端返回資料必須是json或xml格式。\n  RESTful 風格並非標準規範，作用僅是減少工程師之間的溝通成本。\n當碰上敏感資料時(身分證,信用卡號)，依然使用安全性較高的方法即可。\n","permalink":"https://jason11254.github.io/blog/restful/","tags":["RESTful"],"title":"RESTful設計風格"},{"categories":["筆記"],"contents":"Bean 就是由 Spring容器所管理的 Object。\nBean 的名稱默認為該Class名稱且第一個字變為小寫。\n創建Bean 方法1：\n​\t在class上加上@Component，使這個class變成Spring容器所管理的Bean。\n​\t範例：\n  建立interface Fruit\npublic interface Fruit{\rvoid print(String message);\r}   建立class Apple 繼承 Fruit，並使用@Component使其成為Spring容器管理的Bean。\n@Component\rclass Apple implements Fruit{\r@Overwrite\rpublic void print(String message){\rSystem.out.println(\u0026#34;這顆蘋果，\u0026#34;+message);\r}\r} 這樣當Spring程式運行時，Spring容器就會自動去生成一個名為apple的Bean。\n  方法2：\n  先在class上加上@Configuration，表示這個class是拿來設定Spring的。\n@Configuration\rclass MyConfiguration{\r...\r}   然後在class設定要Spring容器幫忙建立的Bean，並在該方法上加上@Bean註解。\n@Configuration\rclass MyConfiguration{\r@Bean\rpublic Student createStudent(){\rreturn new Student();\r}\r} 這樣當Spring程式運行時，Spring容器就會自動去生成一個名為student的Bean。\n  注入Bean 使用@Autowired 將Spring容器建立的Bean注入至需要使用的地方。\n範例：\n  創建Class Person 並加上@Component使其成為Spring容器管理的Bean。\n@Component\rpublic class Person {}   建立 Fruit 物件 apple，並使用@Autowired註解，讓Spring容器將對應的Bean注入至apple。\n@Component\rpublic class Person {\r@Autowired\rprivate Fruit myFruit;\rpublic void myFruit(){\rmyFruit.print(\u0026#34;是我的。\u0026#34;);\r}\r} 由於myFruit物件是Fruit類型，Spring容器注入時會尋找Fruit的Bean或是繼承Fruit的Bean。\n而class Apple有繼承Fruit介面，因此這裡Spring容器會將apple(Bean名字默認為原名稱的小寫)的Bean注入至myFruit。\n執行 myFruit() 可以得到結果print出「這顆蘋果，是我的。」。\n  另外可以使用@Qualifier來指定需要注入哪一個Bean。\n範例：\n  再建立一個class Orange也去繼承Fruit。\n@Component\rclass Orange implements Fruit{\r@Overwrite\rpublic void print(String message){\rSystem.out.println(\u0026#34;這顆橘子，\u0026#34;+message);\r}\r}   此時因為Orange和Apple都是繼承Fruit的Bean，導致原本Person內的myApple在Spring注入時會出錯，因為Spring容器不知道你要注入那一個Bean。\n這時可以加上@Qualifier註解，用來指定要那一個Bean。\n用法：@Qualifier(\u0026ldquo;Bean名稱\u0026rdquo;) 提醒：Bean名稱默認是class名稱第一個字改小寫。因此Apple的Bean為apple，Orange的Bean為orange。\n@Component\rpublic class Person {\r@Autowired\r@Qualifier(\u0026#34;orange\u0026#34;)\rprivate Fruit myFruit;\rpublic void myFruit(){\rmyFruit.print(\u0026#34;是我的。\u0026#34;);\r}\r} 範例中使用@Qualifier(\u0026ldquo;orange\u0026rdquo;)，因此最後 myFruit() 執行結果會是print出「這顆橘子，是我的。」。\n  ","permalink":"https://jason11254.github.io/blog/springbean/","tags":["Java","Spring","IoC"],"title":"Spring學習筆記04-Bean"},{"categories":["筆記"],"contents":"Spring 前後端請求與回應 簡單筆記。\nHttp 協議：規定前後端程式之間的資料傳輸格式。\n格式如下：\n   Http Request (請求) Http Response(回應)     http method (get,post,put\u0026hellip;等) http status code (200,404 \u0026hellip; 等)   url (網址) response header   request header response body (後端回傳資料會在這裡)   request body (前端json資料通常放這裡)     HTTP 狀態碼 (http status code) http 狀態碼依照首位數字不同分為五大類。\n   狀態碼 常見範例     1xx：資訊 很少用   2xx：成功 200 (請求成功)，201(請求成功且資源被創建)，202(請求成功，但後端尚未處理完成)   3xx：重新導向 301 (永久重新導向，通常出現在網站搬家)，302(暫時重新導向)   4xx：前端請求錯誤 400 (前端參數請求錯誤)，401 (沒通過身分驗證)，403 (請求遭到拒絕)，404 (網站不存在)   5xx：後端處理錯誤 500 (後端發生錯誤，可能為bug導致)    URL 路徑對應 使用標籤@RequestMapping，範例如下：\n當前端發送請求至 url：/student 時，可以用以下方法對應。\n@RequestMapping(\u0026#34;/student\u0026#34;)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 配合Rest風格可以限制前端必須使用何種 http method 發送請求。\n範例限制必須以GET來發送請求：\n@RequestMapping(value = \u0026#34;/students\u0026#34;, method = RequestMethod.GET)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 若覺得上面這樣設定太麻煩也能直接使用@GetMapping，@PostMapping，@PutMapping，@DeleteMapping標籤代替@RequestMapping。\n修改上方範例：\n@GetMapping(\u0026#34;/student\u0026#34;)\rpublic String testURL(){\rreturn \u0026#34;success\u0026#34;;\r} 即可得到相同效果。\n取得 Request 參數方法   當參數放在url路徑內的問號後面時，url：/students?id=11040303\n使用 @RequestParam 取得參數，且參數名稱需與url中的名稱相同。也可以使用name=\u0026ldquo;參數名\u0026quot;來指定要的資料，但不建議。\n範例：\nurl：/product?id=41252\n@RequestMapping(\u0026#34;/product\u0026#34;)\rpublic String testRequestParam(@RequestParam Integer id){\rSystem.out.println(\u0026#34;商品編號為：\u0026#34;+id);\rreturn \u0026#34;success\u0026#34;;\r}   當參數放在request body 時，使用 @RequestBody 取得 requestbody 內的 json 內容。\n範例：\nurl：/testBody\nrequestbody：{\u0026ldquo;id\u0026rdquo;:123, \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Amy\u0026rdquo; }\nclass Student{\rprivate Integer id;\rprivate String name;\r...\rgetter and setter\r...\r} @RequestMapping(\u0026#34;/testBody\u0026#34;)\rpublic String testRequestBody(@RequestBody Student student){\rSystem.out.println(\u0026#34;id: \u0026#34; + student.getId());\rSystem.out.println(\u0026#34;name: \u0026#34; + student.getName());\rreturn \u0026#34;success\u0026#34;;\r}   當參數放在request header 時，使用 @RequestHeader 取得 requestHeader 內的參數。\n範例：\nurl：/testHeader\nrequestheader：Content-Type:application/json\n@RequestMapping(\u0026#34;/testHeader\u0026#34;)\rpublic String testHeader(@RequestHeader(name=\u0026#34;Content-Type\u0026#34;) String info){\rSystem.out.println(\u0026#34;info: \u0026#34; + info);\rreturn \u0026#34;success\u0026#34;;\r} 由於Java內需使用駝峰式命名法，但Content-Type不屬於此類，因此使用name=\u0026ldquo;Content-Type\u0026rdquo; 來直接指定要這個header資料。\n  當參數直接放在url路徑上時，使用@PathVariable來取得路徑上的參數。\n範例：\nurl：/testUrl/4104321/Judy\n@RequestMapping(\u0026#34;/testUrl/{id}/{name}\u0026#34;)\rpublic String testPathVariable(@PathVariable Integer id,@PathVariable String name){\rSystem.out.println(\u0026#34;Path id: \u0026#34; + id + \u0026#34;, Path name: \u0026#34; + name);\rreturn \u0026#34;success\u0026#34;;\r}   ","permalink":"https://jason11254.github.io/blog/spring%E8%AB%8B%E6%B1%82%E8%88%87%E5%9B%9E%E6%87%89/","tags":["Java","Spring","HTTP"],"title":"Spring學習筆記03-前後端請求與回應"},{"categories":["筆記"],"contents":"AOP (Aspect Oriented Programming) 切面導向程式設計，意思是將很多方法使用的共同邏輯寫在切面裡，由切面統一處理這段程式。\n這裡假設沒有使用切面，每次執行方法時都必須在方法程式開始時輸出【開始】與方法程式結束時【結束】，那麼程式碼會長這樣：\npublic class ExampleClass{\rpublic void fun01(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r...\r一些方法程式\r...\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 如範例所見，必須在進入方法時與方法結束時加入print語法來輸出文字。只有一個方法時還很輕鬆，但當有10個方法時，這段程式就必須重複寫10次。\n而由AOP統一處理時則不需要重複寫這段程式，僅需要設定好切面，由切面去執行輸出【開始】與【結束】的任務。\n切面基礎設定  在要成為切面的class上加上@Aspect與@Component，兩個註解順序不重要，但必須兩者都存在。  @Aspect\r@Component\rpublic class MyAspect {\r...\r}  使用@Before與@After註解，即可設定在方法前後需要執行的程式。\n切入點設定範例：@Before (\u0026ldquo;execution(* 路徑.目標Class.*(..))\u0026quot;)，\n上面的設定會讓目標Class中所有方法執行前都先執行Before內的程式，After設定寫法相同。\n  @Aspect\r@Component\rpublic class MyAspect {\r@Before(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void before(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r}\r@After(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void after(){\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 拿掉原本在目標Class內寫的print方法，範例為ExampleClass。  public class ExampleClass{\rpublic void fun01(){\r...\r一些方法程式\r...\r}\r} 建立main執行fun01()方法即可看到執行前後切面自動輸出【開始】與【結束】。 可以使用@Around來同時設定before與after，但是設定起來比較麻煩。得到的結果會跟上面@Before跟@After的結果一樣。  @Aspect\r@Component\rpublic class MyAspect {\r@Around(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic Object around(ProceedingJoinPoint pjp) throws Throwable{\rSystem.out.println(\u0026#34;開始\u0026#34;);\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之上就是before。\rObject obj = pjp.proceed();\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之下就是after。\rSystem.out.println(\u0026#34;結束\u0026#34;);\rreturn obj;\r}\r} Spring AOP的發展  權限認證 e.g. Spring Security 統一處理Exceptuon e.g. @ControllerAdvice Log  ","permalink":"https://jason11254.github.io/blog/springaop/","tags":["Java","Spring","AOP"],"title":"Spring學習筆記02-AOP簡介"},{"categories":["筆記"],"contents":"IoC (Inversion of Control) - 控制反轉，將object的控制權交給Spring容器管理。\n由Spring容器管理的object則稱為bean。\nSpring IoC簡易流程   在目標class上加上@Component：\n@Component只能加在class上，使用後即可將該class變為Spring容器管理的bean。\n  @Component\rpublic class Apple {\rpublic void print(String message){\rSystem.out.println(\u0026#34;這顆蘋果，\u0026#34;+message);\r}\r} 在需要該物件的class上也加上@Component：  @Component\rpublic class Person {\r...\r}  最後使用@Autowired將bean注入物件，完成DI (Dependency Inject) - 依賴注入。\n@Autowired只能加在物件上，用於取得Spring容器中的bean。\n範例中取得了Spring容器中Apple的bean，注入物件apple。\n  @Component\rpublic class Person {\r@Autowired\rprivate Apple apple;\rpublic void myApple(){\rapple.print(\u0026#34;是我的。\u0026#34;);\r}\r}  創建main運行myApple()方法後即可看到console上的運行結果：這顆蘋果，是我的。\n而使用Spring容器建立的bean注入至物件中即是IoC的流程。\n  Spring IoC 優點：  使程式之間關聯性降低，在修改上可以不用到處尋找其他有關聯到的地方。 object的生命週期由Spring容器管理，無須工程師手動操作。  ","permalink":"https://jason11254.github.io/blog/springioc/","tags":["Java","Spring","IoC"],"title":"Spring學習筆記01-IoC簡介"}]