[{"categories":["筆記"],"contents":"IoC (Inversion of Control) - 控制反轉，將object的控制權交給Spring容器管理。\n由Spring容器管理的object則稱為bean。\nSpring IoC簡易流程   在目標class上加上@Component：\n@Component只能加在class上，使用後即可將該class變為Spring容器管理的bean。\n  @Component\rpublic class Apple {\rpublic void print(String message){\rSystem.out.println(\u0026#34;這顆蘋果，\u0026#34;+message);\r}\r} 在需要該物件的class上也加上@Component：  @Component\rpublic class Person {\r...\r}  最後使用@Autowired將bean注入物件，完成DI (Dependency Inject) - 依賴注入。\n@Autowired只能加在物件上，用於取得Spring容器中的bean。\n範例中取得了Spring容器中Apple的bean，注入物件apple。\n  @Component\rpublic class Person {\r@Autowired\rprivate Apple apple;\rpublic void myApple(){\rapple.print(\u0026#34;是我的。\u0026#34;);\r}\r}  創建main運行myApple()方法後即可看到console上的運行結果：這顆蘋果，是我的。\n而使用Spring容器建立的bean注入至物件中即是IoC的流程。\n  Spring IoC 優點：  使程式之間關聯性降低，在修改上可以不用到處尋找其他有關聯到的地方。 object的生命週期由Spring容器管理，無須工程師手動操作。  ","permalink":"https://jason11254.github.io/blog/springioc/","tags":["Java","Spring","IoC"],"title":"Spring學習筆記01-IoC簡介"},{"categories":["筆記"],"contents":"AOP (Aspect Oriented Programming) 切面導向程式設計，意思是將很多方法使用的共同邏輯寫在切面裡，由切面統一處理這段程式。\n這裡假設沒有使用切面，每次執行方法時都必須在方法程式開始時輸出【開始】與方法程式結束時【結束】，那麼程式碼會長這樣：\npublic class ExampleClass{\rpublic void fun01(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r...\r一些方法程式\r...\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 如範例所見，必須在進入方法時與方法結束時加入print語法來輸出文字。只有一個方法時還很輕鬆，但當有10個方法時，這段程式就必須重複寫10次。\n而由AOP統一處理時則不需要重複寫這段程式，僅需要設定好切面，由切面去執行輸出【開始】與【結束】的任務。\n切面基礎設定  在要成為切面的class上加上@Aspect與@Component，兩個標籤順序不重要，但必須兩者都存在。  @Aspect\r@Component\rpublic class MyAspect {\r...\r}  使用@Before與@After標籤，即可設定在方法前後需要執行的程式。\n切入點設定範例：@Before (\u0026ldquo;execution(* 路徑.目標Class.*(..))\u0026quot;)，\n上面的設定會讓目標Class中所有方法執行前都先執行Before內的程式，After設定寫法相同。\n  @Aspect\r@Component\rpublic class MyAspect {\r@Before(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void before(){\rSystem.out.println(\u0026#34;開始\u0026#34;);\r}\r@After(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic void after(){\rSystem.out.println(\u0026#34;結束\u0026#34;);\r}\r} 拿掉原本在目標Class內寫的print方法，範例為ExampleClass。  public class ExampleClass{\rpublic void fun01(){\r...\r一些方法程式\r...\r}\r} 建立main執行fun01()方法即可看到執行前後切面自動輸出【開始】與【結束】。 可以使用@Around來同時設定before與after，但是設定起來比較麻煩。得到的結果會跟上面@Before跟@After的結果一樣。  @Aspect\r@Component\rpublic class MyAspect {\r@Around(\u0026#34;execution(* com.example.springbootproject.ExampleClass.*(..))\u0026#34;)\rpublic Object around(ProceedingJoinPoint pjp) throws Throwable{\rSystem.out.println(\u0026#34;開始\u0026#34;);\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之上就是before。\rObject obj = pjp.proceed();\r//中間這行pjp.proceed()就是要執行切入點的方法。這行之下就是after。\rSystem.out.println(\u0026#34;結束\u0026#34;);\rreturn obj;\r}\r} Spring AOP的發展  權限認證 e.g. Spring Security 統一處理Exceptuon e.g. @ControllerAdvice Log  ","permalink":"https://jason11254.github.io/blog/springaop/","tags":["Java","Spring","AOP"],"title":"Spring學習筆記02-AOP簡介"}]